```
go run cmd/apiserver/main.go --secure-port 1443 \
--kubeconfig /etc/kubernetes/admin.conf \
--etcd-servers https://172.16.91.10:2379 \
--etcd-cafile /etc/kubernetes/pki/etcd/ca.crt \
--etcd-certfile /etc/kubernetes/pki/etcd/server.crt \
--etcd-keyfile /etc/kubernetes/pki/etcd/server.key
```

但是此时启动成功后, 使用`kubectl api-resources`仍然找不到我们的自定义资源 - `PodCluster`, 这就导致我们没有办法通过创建`PodCluster`资源.

这是因为我们还需要手动创建`APIService`资源将自定义资源注册一下, 就像写CRD工程时要创建一个CRD资源对象进行注册, 见参考文章4.

...不过我自己写了好多个, `apply`后, `APIService`资源的状态总是不对.

后来找到了参考文章5, 尝试了`apiserver-boot build`命令, 也更进一步地了解`APIService`的生效原理.

## APIService的部署与使用

`apiserver-builder`项目构建的工程需要向`apiserver`注册我们的自定义资源(`PodCluster`), 而`apiserver`需要确认该资源的处理工程正常运行, `APIService`的作用就是为`apiserver`指明了通过哪个`Service`访问我们的工程.

这就要求我们需要事先容器化部署我们的工程, 也包括相应的`Service`资源.

### 部署

要在 pod 中运行 apiserver 工程, 先 build 出一个二进制文件吧.

```
go build -o ./bin/podcluster_server cmd/apiserver/main.go
```

该工程启动需要指定`etcd`的客户端证书, 我们通过`secret`挂载到`pod`中.

```
k create cm k8s-certs-cfg --from-file=/etc/kubernetes/pki
k create cm etcd-certs-cfg --from-file=/etc/kubernetes/pki/etcd
```

然后是[Deployment](./deploy/01.deploy.yaml)与[Service](./deploy/02.svc.yaml)

### 生成APIService

在GOPATH下的工程目录中执行如下命令, 生成`APIService`部署文件.

```
apiserver-boot build config --name podcluster-apiserver --namespace kube-system --image podcluster-apiserver:0.0.1
```

上面的命令会创建`config/apiserver.yaml`文件和一些证书文件, 前者东西太多(包含了`Deployment`和`Service`资源, 甚至还包括`etcd`的部署文件), 所以没有加入到仓库中, 我们只提取了[APIService](./deploy/03.apiservice.yaml)

创建`APIService`后, 其资源状态显示如下

```console
$ k get apiservice
NAME                                   SERVICE                      AVAILABLE                      AGE
v1.kubegroup.generals.space      kube-system/podcluster-apiserver   False (FailedDiscoveryCheck)   4s
```

### 容器内启动进程

我们将第一步编译的`podcluster_server`二进制文件拷贝到`Deployment`生成的`Pod`中(假设在`/podcluster_server`), 同时把`/etc/kubernetes/admin.conf`文件拷贝进去(这种方式不建议使用, 以后要换成`InCluster`的配置, 不过还需要创建`Role`和`RoleBinding`), 然后按照如下命令启动.

```
/podcluster_server \
--secure-port 1443 \
--kubeconfig /etc/kubernetes/admin.conf \
--authentication-kubeconfig=/etc/kubernetes/admin.conf \
--authorization-kubeconfig=/etc/kubernetes/admin.conf \
--etcd-servers https://172.16.91.10:2379 \
--etcd-cafile /etc/kubernetes/pki/etcd/ca.crt \
--etcd-certfile /etc/kubernetes/pki/etcd/server.crt \
--etcd-keyfile /etc/kubernetes/pki/etcd/server.key
```

> authentication: 认证, 身份验证
> 
> authorization: 鉴权, 授权, 批准

ok, 现在可以通过`kubectl api-resource`查询我们的资源了, 现在`APIService`资源的状态也正常了.

```console
$ k get apiservice
NAME                         SERVICE                            AVAILABLE   AGE
v1.kubegroup.generals.space  kube-system/podcluster-apiserver   True        24m
$ k api-resources
NAME            SHORTNAMES   APIGROUP                         NAMESPACED   KIND
podclusters                  kubegroup.generals.space         true         Podcluster
...
```

如果 podcluster-server 的进程退出, 那么再进行`k api-resources`查询的时候, 可能会在底部报如下错误

```
error: unable to retrieve the complete list of server APIs: kubegroup.generals.space/v1: the server is currently unable to handle the request
```

这是正常现象.

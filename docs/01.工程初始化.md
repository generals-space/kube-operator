# 01.工程初始化

参考文章

1. [Installing the apiserver build tools](https://github.com/kubernetes-sigs/apiserver-builder-alpha/blob/master/docs/installing.md)
    - 安装方法
2. [Getting started (using v0.1-alpha.6)](https://github.com/kubernetes-sigs/apiserver-builder-alpha/blob/master/docs/tools_user_guide.md)
3. [Step by step example](https://github.com/kubernetes-sigs/apiserver-builder-alpha/commits/example-simple)
4. [concepts/aggregation](https://github.com/kubernetes-sigs/apiserver-builder-alpha/blob/master/docs/concepts/aggregation.md)
    - `kubectl api-resources`的工作流程
    - 通过创建`APIService`资源注册自定义的资源类型
5. [使用Aggregated APIServer的方式构建API服务](https://jeremyxu2010.github.io/2019/07/%E4%BD%BF%E7%94%A8aggregated-apiserver%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9E%84%E5%BB%BAapi%E6%9C%8D%E5%8A%A1/)
    - 全面的使用手册, 构建流程

## 环境准备

- go: 1.13.11
- kuber: 1.17.2
- apiserver-boot(apiserver-builder-alpha): 
    - ApiserverBuilderVersion: v1.18.0
    - KubernetesVendor: kubernetes-1.18.4 
    - GitCommit: d5fdf8c1b65a7c6068806b540998889ec5114c36
    - BuildDate: 2020-06-24-19:15:49

## 初始化工程

```console
$ mkdir -p $GOPATH/src/generals-space
$ pwd
/home/generals-space/kube-operator
$ ln -s /home/generals-space/kube-operator $GOPATH/src/generals-space/kube-operator
$ cd $GOPATH/src/generals-space/kube-operator
```

`apiserver-boot`命令需要在`GOPATH`目录下执行, 为了避免之后将工程从`GOPATH`内外反复迁移, 可以在`GOPATH`外创建工程, 并创建到`GOPATH`下的软链接, 执行`go mod`或是`go run`等命令时在原目录, 执行`apiserver-boot`时在软链接目录...

## boilerplate

首先在根目录下创建空的`boilerplate.go.txt`文件.

> `boilerplate`: (可供模仿的)样板文件, 文件范例.

一般这个文件的内容是`liscence`信息, 如下. 

```
/*
Licensed under the Apache License, Version 2.0 (the "License");
...
```

在生成代码后, 每个`.go`文件都将以这个文件的内容作为开头.

## apiserver-boot init

```console
$ apiserver-boot init repo --domain generals.space
I0407 23:09:55.524485   28481 repo.go:94] rendering go mod file
2021-04-07 23:09:55.526390 I | extracted tarball into .: 2 files, 1 dirs (5.342872ms)
```

`--domain`与`group`并不相同, 可以说, `--domain`是`group`的后缀.

虽然我们的工程在`GOPATH`下, 但是你会发现, `init`后的工程中包含了`go.mod`与`go.sum`, 这是因为`apiserver-boot`这个工具本身仍然工作在`GOPATH`模式. 但是当我们的工程结构构建完成后, 是可以使用`go.mod`进行依赖管理的.

## apiserver-boot create group version resource

```console
$ apiserver-boot create group version resource --group kubegroup --version v1 --kind PodCluster
Create Resource [y/n]
y
Create Controller [y/n]
y
Create Admission Controller [y/n]
y
```

> `--non-namespaced`参数可以指定crd对象为`Cluster`范围.

## apiserver-boot build generated

参考文章2的剩余部分其实都不用看了, 都是用`apiserver-boot`启动`apiserver`和`controller-manager`和运行test代码的方法.

后面的部分我是参考的参考文章3来的, 仔细分析了一下, 找到了接下来的步骤, 就是生成模板代码, 就像在写CRD时用`code-generator`生成代码一样, 需要使用`apiserver-boot build generated`命令.

这个命令貌似很"守旧", 要求必须存在`GOROOT`环境变量, 否则会报错.

一般来说, `GOROOT`的值就是`go`可执行文件所在的目录, 像`/usr/local/go`这样的, 不需要用户手动设置, 执行`go env`时会自动检测到此变量, 但这对`apiserver-boot`是无效的.

设置好`GOROOT`后, 需要下载依赖(生成代码也是需要很多依赖的), 但是这些依赖需要使用`go mod`的形式下载.

> 如果直接进入到`cmd/apiserver`目录下, 执行`go get -v`的话, 很多依赖库的版本都发生了变动, 之后别说正常生成代码了, 就连依赖都不一定能完整的拉下来.

上面说过了, 生成的工程框架是用的`go.mod`作依赖管理的, 但这个工程目前仍在`GOPATH`下, 所以如果要安装依赖, 要先把工程目录移到`GOPATH`之外, 用`go mod`将依赖下载到`vendor`目录下后, 再把`vendor`目录中的内容放到`GOPATH`下.

> 为此, 你可能还需要先将`GOPATH/src`下的库先清空.

```bash
## 到GOPATH外下载依赖
cd /home/generals-space/kube-operator
go mod download
go mod vendor
## 将下载好的依赖拷贝到GOPATH下(事先清理GOPATH)
rm -rf $GOPATH/src
cp -r ./vendor $GOPATH/src
## 再回到GOPATH下
cd $GOPATH/src/generals-space/kube-operator
```

现在终于可以生成代码了...

```console
$ apiserver-boot build generated
```

> 这个过程花的时间好长啊...

生成完成后, 就可以编写业务代码了.
